
function Parse (text, { ast = [], initial = 0 }) {

  const inLiquidToken = -1
  const inHTMLToken = -1
  const inString = -1
  const inComment = -1
  const inLiquidBlock = false
  const inHTMLBlock = false

  function withinHtml () {

    if (tag) {
      if (text.charCodeAt(n) === Characters.RAN) {
        AST[nodeHTML].token = [ text.substring(inHTML, text.indexOf('>', n)) ]
      } else if (text.charCodeAt(n + 1) === Characters.BWS && tag[0] === AST[nodeHTML]?.name) {
        const s = text.indexOf('>', n + tag[0].length + 1)
        AST[nodeHTML].token.push(text.substring(n, s))
        inHTML = -1
        scan.goto(n + s)
      } else {
        nodeHTML = AST.push({ name: tag[0] }) - 1
        inHTML = n
      }

    // scan.goto(tag[0].length)
    } else {
    // scan.goto(n)
    }

  }

  function withinLiquid () {

  }

  function withinString () {

  }

}

function getTokenName (n) {

  // console.log(text.charAt(n))

  // if (scan.peekChar(n) === Characters.DSH) n = n + 1

  const match = text.slice(n).match(/[a-zA-Z0-9_]+(?![^.+'"|=<>\-\s}%])/)

  if (match) {
    AST[node].name = match[0]

  } else {

    console.error('PARSER ERROR')
  }

  // scan.goto(n + from + to)

}

function inLiquidToken (n) {

  if (inString >= 0) return

  if (inToken < 0) {
    if (scan.nextChar() === Characters.PER || scan.prevChar() === Characters.LCB) {

      inToken = n
      node = AST.push({}) - 1

      if (scan.peekChar(n + 2) === Characters.DSH) {
        // scan.goto(n + 3)
        // AST[node].whitespace = true
      } else {
        // scan.goto(n + 2)
      }

      getTokenName(n)

      // console.log(text.slice(n), inString)
      // hasWhitespace(n + 2)

    }
  } else if (inToken >= 0) {

    if (scan.nextChar() === Characters.RCB || scan.prevChar() === Characters.RCB) {
      // hasWhitespace(n - 2)
      // console.log(text.slice(n))
      AST[node].token = text.substring(inToken - 1, n + 2)
      inToken = -1
    } else if (scan.prevChar() === Characters.PER) {
      AST[node].token = text.substring(inToken, n + 1)
      inToken = -1
    }

  }

}

function withinString (n) {

  // const lst = text.indexOf(text.charAt(n), n + 1)
  // const str = text.slice(n, lst)

  // if (str.endsWith('\\', lst)) {
  // console.log('string', str)
  // }

  if (inHTML > 0 && inToken < 0) return

  if (inString >= 0) {
    AST[node].string = text.substring(inString, n)
    inString = -1
  //  console.log(inString)
  } else {

    // skip empty strings , e: '' or ""
    console.log(text.charCodeAt(n) !== text.charCodeAt(n + 1))
    if (text.charCodeAt(n) !== text.charCodeAt(n + 1)) {
      inString = scan.next()
    } else {

    }

  }

}

function inHTMLToken (n) {

  const tag = text.slice(n).match(/(?<=<\/?)\b(?:script|style)[^\s]*?/)

  if (tag) {
    if (text.charCodeAt(n) === Characters.RAN) {
      AST[nodeHTML].token = [ text.substring(inHTML, text.indexOf('>', n)) ]
    } else if (text.charCodeAt(n + 1) === Characters.BWS && tag[0] === AST[nodeHTML]?.name) {
      const s = text.indexOf('>', n + tag[0].length + 1)
      AST[nodeHTML].token.push(text.substring(n, s))
      inHTML = -1
      scan.goto(n + s)
    } else {
      nodeHTML = AST.push({ name: tag[0] }) - 1
      inHTML = n
    }

    // scan.goto(tag[0].length)
  } else {
    // scan.goto(n)
  }

}

function isCommentToken () {

}

function skipWhitespace (n) {

  // const nextChar = text.slice(n).search(/\S/)

  // console.log(n + nextChar)
  //  if (nextChar) {
  // scan.goto(n + nextChar)
  // }

}
