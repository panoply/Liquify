"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("path"),a=e(require("inquirer")),i=e(require("execa")),n=require("fs-extra"),r=e(require("chalk")),s=e(require("crypto")),o=e(require("@liquify/specs")),c=e(require("strip-json-comments")),l=e(require("jsonminify")),d=e(require("chokidar")),u=e(require("boxen")),p=e(require("json-to-pretty-yaml")),h=e(require("figlet")),m=e(require("console-clear")),g=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const f=[],y=(e,t)=>void 0!==e&&(t=t||e,f.includes(t)||f.push(t),console.warn("["+y.title+"]",t),!0);y.title="DeprecationWarning";var b=y,w=f;b.once=(...e)=>!f.includes(e[1]||e[0])&&y.apply(void 0,e),b._list=w;const{ALGORITHM:v}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class ${constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!v.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${v.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=g.normalizeInput(e);const t=s.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=g.normalizeInput(e);const t=s.createDecipheriv(this.algorithm,this.key,this.iv,this.options),a=t.update(e,"hex","utf8")+t.final("utf8");return g.normalizeOutput(a)}static getCiphers(){return s.getCiphers()}static getHashes(){return s.getHashes()}static md5(e){return b('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),s.createHash("md5").update(e).digest("hex")}static sha1(e){return b('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),s.createHash("sha1").update(e).digest("hex")}static hash(e,t){if($.hasHash(t))return s.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==$.getHashes().indexOf(e)}}var j=$;const S=new j("sissel siv"),{log:k}=console;const x=require("../../package.json"),{log:q}=console,O=e=>t=>q(r`{redBright Error} in {red ${e}}\n${t}\n`),C=async(e,t,a,i)=>{const s=new j("sissel siv"),o=s.encode(i),c=s.encode(e);return await n.writeFile(`${t}/${c}.js`,`module.exports="${o}";`),global.watch||q(r`encrypted {magenta ${e}} to {green ${c}}`),a.encrypt[c]=`${c}=require("./${c}")`,a},P=async(e,t)=>{await C("specs",e,t,t.specs),await C("grammar",e,t,t.grammar);const{parsing:a}=(e=>{const{parsing:t,cache:a,cache:{standard:i}}=e;for(const n in a){"object"!=typeof t[n]&&(t[n]={});const{filter:r=[],object:s=[]}=a[n];e.parsing[n].objects=[...s].sort(),e.parsing[n].filters="standard"!==n?[...r,...i.filter].sort():i.filter.sort()}return e})(t),{encrypt:i}=await C("parsing",e,t,a),r=`${"const "+Object.values(i).join(",")};module.exports={${Object.keys(i).join(",")}};`;await n.writeFile(e+"/index.js",r)},I=(e,a)=>async i=>{const r=i?`${e}/${i}`:e,s=t.basename(r).replace(/\.[^/.]+$/,""),o=await n.readFile(r),d=c(o.toString()),u=JSON.parse(l(d)),{cache:p}=((e,t,a)=>{t.cache[e]={deprecated:[]};for(const[i,{type:n,deprecated:r}]of Object.entries(a))t.cache[e][n]||(t.cache[e][n]=[]),r?t.cache[e].deprecated.push(i):t.cache[e][n].push(i);return t})(s,a,u);a.specs[s]=u,a.grammar[s]=((e,t={})=>{for(const a in e)e[a].length&&(t[a]=`(${e[a].join("|")})`);return t})(p[s])},L=async(e,t,a)=>{const i=await n.readdir(e),r=I(e,a),s=O(e);for(const e of i)await r(e).catch(s);return await P(t,a).catch(s),a};const E=async e=>{const t=await n.readFile(e),a=c(t.toString()),i=JSON.parse(a);return i.$schema&&delete i.$schema,i};var N=[{command:"grammar",filters:[{command:"create"}]},{command:"peek"},{command:"package"},{command:"publish"},{command:"schema"},{command:"server"},{command:"specs"},{command:"client",filters:[{command:"vscode"},{command:"sublime"},{command:"atom"}]}],B=[{name:"config",short:"c",description:"Use configuration file (defaults to `.liquifyrc.json`"},{name:"watch",short:"w",description:"Watch and bundle file/s"},{name:"main",short:"m",description:"Define a main (entry) configuration file"},{name:"input",short:"i",description:"Input path to directory of file/s"},{name:"output",short:"o",description:"Output path destination of bundled file/s"},{name:"prod",short:"p",description:"Production bundle build"},{name:"dev",short:"d",description:"Develop bundle build (default)"},{name:"postinstall",short:"pi",description:"Post install"},{name:"help",short:"h",description:"Shows the CLI help and commands list"}],H={banner:({name:e,main:a,version:i,author:r})=>`\n/**\n * @license\n *\n * THIS IS PROPRIETARY CODE\n *\n * Copyright of Vellocet, Inc - All Rights Reserved.\n * Unauthorized copying or modification of this file, via any medium is strictly prohibited.\n * Please refer to the LICENSE.txt and/or ThirdPartyNotices.txt files included in bundle.\n *\n * ${t.basename(a)}\n *\n * Package:  ${e}\n * Version:  ${i}\n * Updated:  ${new Date(n.statSync(a).mtimeMs).toISOString().replace(/T/," ").substr(0,19)}\n * Website:  https://www.liquify.dev\n * License:  See LICENSE\n *\n * Written by ${r}\n *\n */`};exports.rollup=H,exports.run=async e=>{const s=process.cwd(),c=(({_:[e,t=null]})=>{for(const{command:a,filters:i}of N){if(console.log(a===e),a===e)return{command:a,filter:t};if(a===e&&t&&i.length>0)for(const e of i)if(e.command===t)return{command:a,filter:t}}})(e);if(console.log(e),!c)return O("Command\n")(JSON.stringify(c));const g=((e,a)=>async([i,n])=>{for(const{name:r,short:s}of B)r!==i&&s!==i||await Object.assign(a,{[r]:["config","main","input","output","peek"].includes(r)?t.resolve(e,n):n})})(s,c);switch(Object.entries(e).forEach(await g),c.command){case"specs":await(async(e,a={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const{input:i,output:n}=e,s=O(i);if(e.watch){q(r`{bold.cyan Liquid Specifications}\n`),await L(i,n,a).catch(s);const e=d.watch(i+"/**",{persistent:!0}),o=((e,a)=>async i=>{const n=t.basename(i),s=O(n);q(r`{cyan changed} '{yellow ${n}}'`);const o=I(i,a);await o().catch(s),await P(e,a).catch(s)})(n,a);global.watch=!0,e.on("change",o).on("error",s)}else q(r`{bold.cyan Liquid Specifications}\n`),await L(i,n,a).catch(s)})(c);break;case"peek":await(async e=>{const{input:s}=e,o=await n.readdir(s),c=(e=>a=>"index"!==(a=t.basename(a).replace(/\.[^/.]+$/,""))&&(r`${S.decode(a)}    {dim.magenta ${a} }`,t.resolve(e,a)))(s),l=o.map(c).filter(Boolean),{file:d}=await a.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:l}]),u=await i("pnpx",["fx",d+".js"],{stdio:"inherit"});try{await u}catch(e){k(""+e.shortMessage)}})(c);break;case"grammar":await(async(e,a={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const{output:i}=e,s=process.cwd(),c=await E(e.main),d=await E(t.resolve(s,c.input)),u=await(async e=>S.decode(o.bb7485c5a2338a))(),h=(m=i,async({input:e,output:t})=>{const a=await E(e),i=l(JSON.stringify(a)),s=p.stringify(a);await n.writeFile(`${m}/${t}.json`,i),q(r`{cyan JSON Injection} {green ${t}.json}`),await n.writeFile(`${m}/${t}.yaml`,s),q(r`{yellow YAML Injection} {green ${t}.yaml}`)});var m;const g=(async(e,t,a)=>a=>{if(!e[a.variant])return;const{repository:i}=t,{object:n}=e[a.variant];i.objects.patterns})(u,d);c.injections.forEach(await h),c.variations.forEach(await g)})(c);break;default:await(async(e=[{type:"list",name:"run",message:"Select operation:",choices:[r`Bundle    {gray.italic Build and compile bundles}`,r`Package   {gray.italic Packaging execution, eg: npm pack}`,r`Git       {gray.italic Common git related operations for the project}`,r`Publish   {gray.italic Publish to CDN, Netlify, Marketplace etc}`,r`Test      {gray.italic Run various tests}`,r`Config    {gray.italic Project configuration and settings}`]}])=>{m(!0),q(r`{cyan ${h.textSync("Liquify CLI",{font:"Slant",horizontalLayout:"controlled smushing"})}}`),q(u([r`{magentaBright Package}{dim :} ${x.name}                              `,r`{magentaBright Version}{dim :} ${x.version}                           `,r`{magentaBright Private}{dim :} ${x.private}`].join("\n"),{padding:0,borderColor:"gray",dimBorder:!0,borderStyle:{topLeft:" ",topRight:" ",bottomLeft:" ",bottomRight:" ",horizontal:"-",vertical:" "}}));const{run:t}=await a.prompt(e);return t.toLowerCase().substring(0,t.indexOf(" ")),await(async()=>{const{bundle:e}=await a.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:[r`Client    {gray.italic Build and compile bundles}`,r`Grammar   {gray.italic Packaging execution, eg: npm pack}`,r`Schema    {gray.italic Common git related operations for the project}`,r`Server    {gray.italic Publish to CDN, Netlify, Marketplace etc}`,r`Specs     {gray.italic Run various tests}`,r`{magenta < Go Back}`]}]),t=e.toLowerCase().substring(0,e.indexOf(" ")),n=O(t);return await i("pnpm",["run","build","--filter","./packages/specs"],{stdio:"inherit"}).catch(n)})()})()}};
