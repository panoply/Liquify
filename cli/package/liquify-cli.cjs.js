"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var t=require("path"),r=e(t),n=e(require("chalk")),o=e(require("crypto"));require("@liquify/specs");var s=e(require("fs")),i=e(require("util"));require("fs-extra"),require("boxen"),require("strip-json-comments"),require("jsonminify"),require("execa"),require("chokidar"),require("json-to-pretty-yaml"),require("console");var a=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const c=[],u=(e,t)=>void 0!==e&&(t=t||e,c.includes(t)||c.push(t),console.warn("["+u.title+"]",t),!0);u.title="DeprecationWarning";var l=u,d=c;l.once=(...e)=>!c.includes(e[1]||e[0])&&u.apply(void 0,e),l._list=d;const{ALGORITHM:p}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class f{constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!p.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${p.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=a.normalizeInput(e);const t=o.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=a.normalizeInput(e);const t=o.createDecipheriv(this.algorithm,this.key,this.iv,this.options),r=t.update(e,"hex","utf8")+t.final("utf8");return a.normalizeOutput(r)}static getCiphers(){return o.getCiphers()}static getHashes(){return o.getHashes()}static md5(e){return l('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),o.createHash("md5").update(e).digest("hex")}static sha1(e){return l('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),o.createHash("sha1").update(e).digest("hex")}static hash(e,t){if(f.hasHash(t))return o.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==f.getHashes().indexOf(e)}}var h=f;const m=require("./../package.json"),y=new h("af6f97dbaa3ed81e9fc4"),{log:w}=console,g=n.redBright;var v=Object.freeze({__proto__:null,pkg:m,crypto:y,log:w,error:g}),b="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function x(e,t){return e(t={exports:{}},t.exports),t.exports}x((function(e,t){
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright Â© 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
!function(r){t?e.exports=r():"undefined"!=typeof window?window.isWindows=r():void 0!==b?b.isWindows=r():"undefined"!=typeof self?self.isWindows=r():this.isWindows=r()}((function(){return function(){return process&&("win32"===process.platform||/^(msys|cygwin)$/.test(process.env.OSTYPE))}}))}));const k=(e,...t)=>new Promise(r=>{r(e(...t))});var j=k,q=k;j.default=q;const O=e=>{if(!Number.isInteger(e)&&e!==1/0||!(e>0))return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));const t=[];let r=0;const n=()=>{r--,t.length>0&&t.shift()()},o=(e,t,...o)=>{r++;const s=j(e,...o);t(s),s.then(n,n)},s=(n,...s)=>new Promise(i=>((n,s,...i)=>{r<e?o(n,s,...i):t.push(o.bind(null,n,s,...i))})(n,i,...s));return Object.defineProperties(s,{activeCount:{get:()=>r},pendingCount:{get:()=>t.length},clearQueue:{value:()=>{t.length=0}}}),s};var S=O,P=O;S.default=P;class C extends Error{constructor(e){super(),this.value=e}}const E=async(e,t)=>t(await e),H=async e=>{const t=await Promise.all(e);if(!0===t[1])throw new C(t[0]);return!1},I=async(e,t,r)=>{r={concurrency:1/0,preserveOrder:!0,...r};const n=S(r.concurrency),o=[...e].map(e=>[e,n(E,e,t)]),s=S(r.preserveOrder?1:1/0);try{await Promise.all(o.map(e=>s(H,e)))}catch(e){if(e instanceof C)return e.value;throw e}};var z=I,D=I;z.default=D;const{promisify:T}=i,W=T(s.stat),_=T(s.lstat),L={directory:"isDirectory",file:"isFile"};function N({type:e}){if(!(e in L))throw new Error("Invalid type specified: "+e)}const $=(e,t)=>void 0===e||t[L[e]]();var A=async(e,t)=>{N(t={cwd:process.cwd(),type:"file",allowSymlinks:!0,...t});const n=t.allowSymlinks?W:_;return z(e,async e=>{try{const o=await n(r.resolve(t.cwd,e));return $(t.type,o)}catch(e){return!1}},t)};A.sync=(e,t)=>{N(t={cwd:process.cwd(),allowSymlinks:!0,type:"file",...t});const n=t.allowSymlinks?s.statSync:s.lstatSync;for(const o of e)try{const e=n(r.resolve(t.cwd,o));if($(t.type,e))return o}catch(e){}};const{promisify:B}=i,G=B(s.access);var J=async e=>{try{return await G(e),!0}catch(e){return!1}};J.sync=e=>{try{return s.accessSync(e),!0}catch(e){return!1}};var M=x((function(e){const t=Symbol("findUp.stop");e.exports=async(e,n={})=>{let o=r.resolve(n.cwd||"");const{root:s}=r.parse(o),i=[].concat(e),a=async t=>{if("function"!=typeof e)return A(i,t);const r=await e(t.cwd);return"string"==typeof r?A([r],t):r};for(;;){const e=await a({...n,cwd:o});if(e===t)return;if(e)return r.resolve(o,e);if(o===s)return;o=r.dirname(o)}},e.exports.sync=(e,n={})=>{let o=r.resolve(n.cwd||"");const{root:s}=r.parse(o),i=[].concat(e),a=t=>{if("function"!=typeof e)return A.sync(i,t);const r=e(t.cwd);return"string"==typeof r?A.sync([r],t):r};for(;;){const e=a({...n,cwd:o});if(e===t)return;if(e)return r.resolve(o,e);if(o===s)return;o=r.dirname(o)}},e.exports.exists=J,e.exports.sync.exists=J.sync,e.exports.stop=t}));M.sync,M.exists,M.stop;var R={commands:[{command:"bundle",description:"Bundler"},{command:"git",description:"Common git related operations for the project"},{command:"package",description:"Common git related operations for the project"},{command:"peek",description:"Common git related operations for the project"},{command:"publish",description:"Common git related operations for the project"}],flags:[{name:"config",short:"c",description:"Use configuration file (defaults to `.liquifyrc.json`"},{name:"watch",short:"w",description:"Watch and bundle file/s"},{name:"main",short:"m",description:"Define a main (entry) configuration file"},{name:"input",short:"i",description:"Input path to directory of file/s"},{name:"output",short:"o",description:"Output path destination of bundled file/s"},{name:"prod",short:"p",description:"Production bundle build"},{name:"dev",short:"d",description:"Develop bundle build (default)"},{name:"help",short:"h",description:"Shows the CLI help and commands list"},{name:"version",short:"-v",description:"Shows the CLI help and commands list"},{name:"postinstall",description:"Post install"},{name:"preinstall",description:"Pre install"},{name:"dry-run",description:"Dry runner"}]};module.exports=async e=>{const r=Object.create(null),n=await(async(e,{packages:r})=>{e.packages=r;const n=[],o=process.cwd(),s=t.basename(t.resolve(o,"root")),i=t.basename(o);e.root=await M("project",{type:"directory"});for(const t in r){const[o]=Object.keys(r[t]);n.push({command:t,description:o}),i!==t&&s!==t||(e.active=t)}return n})(r,(await Promise.resolve().then((function(){return v}))).pkg);return r.cwd=process.cwd(),R.commands=[...R.commands,...n],await(async(e,r,{_:[n,o=null]})=>{const{commands:s}=r,{packages:i}=e;for(const{command:t,short:r}of s){const s=t===n||r===n;if(s&&!o){e.command=t;break}if(s&&o&&o.length>0){for(const r in i)r===o&&(e.command=t);break}}for(const r in i)if(r===e.command){const[n]=Object.values(i[r]);e.path=t.resolve(e.cwd,n)}return e.command})(r,R,e),console.log(r)};
