"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("fs-extra"),a=require("path"),r=e(require("crypto")),i=e(require("strip-json-comments")),n=e(require("jsonminify")),s=e(require("chalk")),c=e(require("chokidar")),o=e(require("inquirer")),l=e(require("figlet")),u=e(require("boxen")),h=e(require("console-clear")),p=e(require("execa")),d=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const g=[],m=(e,t)=>void 0!==e&&(t=t||e,g.includes(t)||g.push(t),console.warn("["+m.title+"]",t),!0);m.title="DeprecationWarning";var f=m,y=g;f.once=(...e)=>!g.includes(e[1]||e[0])&&m.apply(void 0,e),f._list=y;const{ALGORITHM:b}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class w{constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!b.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${b.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=d.normalizeInput(e);const t=r.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=d.normalizeInput(e);const t=r.createDecipheriv(this.algorithm,this.key,this.iv,this.options),a=t.update(e,"hex","utf8")+t.final("utf8");return d.normalizeOutput(a)}static getCiphers(){return r.getCiphers()}static getHashes(){return r.getHashes()}static md5(e){return f('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),r.createHash("md5").update(e).digest("hex")}static sha1(e){return f('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),r.createHash("sha1").update(e).digest("hex")}static hash(e,t){if(w.hasHash(t))return r.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==w.getHashes().indexOf(e)}}var v=w;const $=require("../../package.json"),{log:S}=console,j=e=>t=>S(s`{redBright Error} in {red ${e}}\n${t}\n`),x=async(e,a,r,i)=>{const n=new v("sissel siv"),c=n.encode(i),o=n.encode(e);return await t.writeFile(`${a}/${o}.js`,`module.exports="${c}";`),global.watch||S(s`encrypted {magenta ${e}} to {green ${o}}`),r.encrypt[o]=`${o}=require("./${o}")`,r},k=async(e,a)=>{await x("specs",e,a,a.specs),await x("grammar",e,a,a.grammar);const{parsing:r}=(e=>{const{parsing:t,cache:a,cache:{standard:r}}=e;for(const i in a){"object"!=typeof t[i]&&(t[i]={});const{filter:n=[],object:s=[]}=a[i];e.parsing[i].objects=[...s].sort(),e.parsing[i].filters="standard"!==i?[...n,...r.filter].sort():r.filter.sort()}return e})(a),{encrypt:i}=await x("parsing",e,a,r),n=`${"const "+Object.values(i).join(",")};module.exports={${Object.keys(i).join(",")}};`;await t.writeFile(e+"/index.js",n)},q=(e,r)=>async s=>{const c=s?`${e}/${s}`:e,o=a.basename(c).replace(/\.[^/.]+$/,""),l=await t.readFile(c),u=i(l.toString()),h=JSON.parse(n(u)),{cache:p}=((e,t,a)=>{t.cache[e]={deprecated:[]};for(const[r,{type:i,deprecated:n}]of Object.entries(a))t.cache[e][i]||(t.cache[e][i]=[]),n?t.cache[e].deprecated.push(r):t.cache[e][i].push(r);return t})(o,r,h);r.specs[o]=h,r.grammar[o]=((e,t={})=>{for(const a in e)e[a].length&&(t[a]=`(${e[a].join("|")})`);return t})(p[o])},O=async(e,a,r)=>{const i=await t.readdir(e),n=q(e,r),s=j(e);for(const e of i)await n(e).catch(s);return await k(a,r).catch(s),r};var C={banner:({name:e,main:r,version:i,author:n})=>`\n/**\n * @license\n *\n * THIS IS PROPRIETARY CODE\n *\n * Copyright of Vellocet, Inc - All Rights Reserved.\n * Unauthorized copying or modification of this file, via any medium is strictly prohibited.\n * Please refer to the LICENSE.txt and/or ThirdPartyNotices.txt files included in bundle.\n *\n * ${a.basename(r)}\n *\n * Package:  ${e}\n * Version:  ${i}\n * Updated:  ${new Date(t.statSync(r).mtimeMs).toISOString().replace(/T/," ").substr(0,19)}\n * Website:  https://www.liquify.dev\n * License:  See LICENSE\n *\n * Written by ${n}\n *\n */`};exports.rollup=C,exports.run=async(e,r)=>{switch(e){case"specs":await(async(e,t={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const r=process.cwd(),i=a.resolve(r,e.input),n=a.resolve(r,e.output),o=j(i);if(e.build)S(s`{bold.cyan Liquid Specifications}\n`),await O(i,n,t).catch(o);else if(e.watch){S(s`{bold.cyan Liquid Specifications}\n`),await O(i,n,t).catch(o);const e=c.watch(i+"/**",{persistent:!0}),r=((e,t)=>async r=>{const i=a.basename(r),n=j(i);S(s`{cyan changed} '{yellow ${i}}'`);const c=q(r,t);await c().catch(n),await k(e,t).catch(n)})(n,t);global.watch=!0,e.on("change",r).on("error",o)}})(r);break;case"grammar":await(async(e,r={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const n=process.cwd(),s=a.resolve(n,e.main);a.resolve(n,e.input),a.resolve(n,e.output),console.log(s);const c=await t.readFile(s),o=JSON.parse(i(c.toString()));console.log(o)})(r);break;default:await(async(e=[{type:"list",name:"run",message:"Select operation:",choices:[s`Bundle    {gray.italic Build and compile bundles}`,s`Package   {gray.italic Packaging execution, eg: npm pack}`,s`Git       {gray.italic Common git related operations for the project}`,s`Publish   {gray.italic Publish to CDN, Netlify, Marketplace etc}`,s`Test      {gray.italic Run various tests}`,s`Config    {gray.italic Project configuration and settings}`]}])=>{h(!0),S(s`{cyan ${l.textSync("Liquify CLI",{font:"Slant",horizontalLayout:"controlled smushing"})}}`),S(u([s`{magentaBright Package}{dim :} ${$.name}                              `,s`{magentaBright Version}{dim :} ${$.version}                           `,s`{magentaBright Private}{dim :} ${$.private}`].join("\n"),{padding:0,borderColor:"gray",dimBorder:!0,borderStyle:{topLeft:" ",topRight:" ",bottomLeft:" ",bottomRight:" ",horizontal:"-",vertical:" "}}));const{run:t}=await o.prompt(e);return t.toLowerCase().substring(0,t.indexOf(" ")),await(async()=>{const{bundle:e}=await o.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:[s`Client    {gray.italic Build and compile bundles}`,s`Grammar   {gray.italic Packaging execution, eg: npm pack}`,s`Schema    {gray.italic Common git related operations for the project}`,s`Server    {gray.italic Publish to CDN, Netlify, Marketplace etc}`,s`Specs     {gray.italic Run various tests}`,s`{magenta < Go Back}`]}]),t=e.toLowerCase().substring(0,e.indexOf(" ")),a=j(t);return await p("pnpm",["run","build","--filter","./packages/specs"],{stdio:"inherit"}).catch(a)})()})()}};
