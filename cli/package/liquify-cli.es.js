import{readdir as e,writeFile as t,readFile as a,statSync as r}from"fs-extra";import{resolve as i,basename as n}from"path";import s from"crypto";import o from"strip-json-comments";import c from"jsonminify";import l from"chalk";import h from"chokidar";import p from"inquirer";import u from"figlet";import m from"boxen";import d from"console-clear";import g from"execa";var f=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const y=[],b=(e,t)=>void 0!==e&&(t=t||e,y.includes(t)||y.push(t),console.warn("["+b.title+"]",t),!0);b.title="DeprecationWarning";var w=b,v=y;w.once=(...e)=>!y.includes(e[1]||e[0])&&b.apply(void 0,e),w._list=v;const{ALGORITHM:$}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class S{constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!$.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${$.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=f.normalizeInput(e);const t=s.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=f.normalizeInput(e);const t=s.createDecipheriv(this.algorithm,this.key,this.iv,this.options),a=t.update(e,"hex","utf8")+t.final("utf8");return f.normalizeOutput(a)}static getCiphers(){return s.getCiphers()}static getHashes(){return s.getHashes()}static md5(e){return w('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),s.createHash("md5").update(e).digest("hex")}static sha1(e){return w('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),s.createHash("sha1").update(e).digest("hex")}static hash(e,t){if(S.hasHash(t))return s.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==S.getHashes().indexOf(e)}}var k=S;const j=require("../package.json"),{log:x}=console,O=e=>t=>x(l`{redBright Error} in {red ${e}}\n${t}\n`),C=async(e,a,r,i)=>{const n=new k("sissel siv"),s=n.encode(i),o=n.encode(e);return await t(`${a}/${o}.js`,`module.exports="${s}";`),global.watch||x(l`encrypted {magenta ${e}} to {green ${o}}`),r.encrypt[o]=`${o}=require("./${o}")`,r},P=async(e,a)=>{await C("specs",e,a,a.specs),await C("grammar",e,a,a.grammar);const{parsing:r}=(e=>{const{parsing:t,cache:a,cache:{standard:r}}=e;for(const i in a){"object"!=typeof t[i]&&(t[i]={});const{filter:n=[],object:s=[]}=a[i];e.parsing[i].objects=[...s].sort(),e.parsing[i].filters="standard"!==i?[...n,...r.filter].sort():r.filter.sort()}return e})(a),{encrypt:i}=await C("parsing",e,a,r),n=`${"const "+Object.values(i).join(",")};module.exports={${Object.keys(i).join(",")}};`;await t(e+"/index.js",n)},L=(e,t)=>async r=>{const i=r?`${e}/${r}`:e,s=n(i).replace(/\.[^/.]+$/,""),l=await a(i),h=o(l.toString()),p=JSON.parse(c(h)),{cache:u}=((e,t,a)=>{t.cache[e]={deprecated:[]};for(const[r,{type:i,deprecated:n}]of Object.entries(a))t.cache[e][i]||(t.cache[e][i]=[]),n?t.cache[e].deprecated.push(r):t.cache[e][i].push(r);return t})(s,t,p);t.specs[s]=p,t.grammar[s]=((e,t={})=>{for(const a in e)e[a].length&&(t[a]=`(${e[a].join("|")})`);return t})(u[s])},I=async(t,a,r)=>{const i=await e(t),n=L(t,r),s=O(t);for(const e of i)await n(e).catch(s);return await P(a,r).catch(s),r};var E={banner:({name:e,main:t,version:a,author:i})=>`\n/**\n * @license\n *\n * THIS IS PROPRIETARY CODE\n *\n * Copyright of Vellocet, Inc - All Rights Reserved.\n * Unauthorized copying or modification of this file, via any medium is strictly prohibited.\n * Please refer to the LICENSE.txt and/or ThirdPartyNotices.txt files included in bundle.\n *\n * ${n(t)}\n *\n * Package:  ${e}\n * Version:  ${a}\n * Updated:  ${new Date(r(t).mtimeMs).toISOString().replace(/T/," ").substr(0,19)}\n * Website:  https://www.liquify.dev\n * License:  See LICENSE\n *\n * Written by ${i}\n *\n */`};const H=async(e,t)=>{switch(e){case"specs":await(async(e,t={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const a=process.cwd(),r=i(a,e.input),s=i(a,e.output),o=O(r);if(e.build)x(l`{bold.cyan Liquid Specifications}\n`),await I(r,s,t).catch(o);else if(e.watch){x(l`{bold.cyan Liquid Specifications}\n`),await I(r,s,t).catch(o);const e=h.watch(r+"/**",{persistent:!0}),a=((e,t)=>async a=>{const r=n(a),i=O(r);x(l`{cyan changed} '{yellow ${r}}'`);const s=L(a,t);await s().catch(i),await P(e,t).catch(i)})(s,t);global.watch=!0,e.on("change",a).on("error",o)}})(t);break;case"grammar":await(async(e,t={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const r=process.cwd(),n=i(r,e.main);i(r,e.input),i(r,e.output),console.log(n);const s=await a(n),c=JSON.parse(o(s.toString()));console.log(c)})(t);break;default:await(async(e=[{type:"list",name:"run",message:"Select operation:",choices:[l`Bundle    {gray.italic Build and compile bundles}`,l`Package   {gray.italic Packaging execution, eg: npm pack}`,l`Git       {gray.italic Common git related operations for the project}`,l`Publish   {gray.italic Publish to CDN, Netlify, Marketplace etc}`,l`Test      {gray.italic Run various tests}`,l`Config    {gray.italic Project configuration and settings}`]}])=>{d(!0),x(l`{cyan ${u.textSync("Liquify CLI",{font:"Slant",horizontalLayout:"controlled smushing"})}}`),x(m([l`{magentaBright Package}{dim :} ${j.name}                              `,l`{magentaBright Version}{dim :} ${j.version}                           `,l`{magentaBright Private}{dim :} ${j.private}`].join("\n"),{padding:0,borderColor:"gray",dimBorder:!0,borderStyle:{topLeft:" ",topRight:" ",bottomLeft:" ",bottomRight:" ",horizontal:"-",vertical:" "}}));const{run:t}=await p.prompt(e);return t.toLowerCase().substring(0,t.indexOf(" ")),await(async()=>{const{bundle:e}=await p.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:[l`Client    {gray.italic Build and compile bundles}`,l`Grammar   {gray.italic Packaging execution, eg: npm pack}`,l`Schema    {gray.italic Common git related operations for the project}`,l`Server    {gray.italic Publish to CDN, Netlify, Marketplace etc}`,l`Specs     {gray.italic Run various tests}`,l`{magenta < Go Back}`]}]),t=e.toLowerCase().substring(0,e.indexOf(" ")),a=O(t);return await g("pnpm",["run","build","--filter","./packages/specs"],{stdio:"inherit"}).catch(a)})()})()}};export{E as rollup,H as run};
