import{basename as e,resolve as t}from"path";import a from"inquirer";import i from"execa";import{readdir as n,writeFile as o,readFile as r,statSync as s}from"fs-extra";import c from"chalk";import l from"crypto";import p from"@liquify/specs";import m from"strip-json-comments";import d from"jsonminify";import h from"chokidar";import u from"boxen";import f from"json-to-pretty-yaml";import g from"figlet";import y from"console-clear";var b=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const w=[],j=(e,t)=>void 0!==e&&(t=t||e,w.includes(t)||w.push(t),console.warn("["+j.title+"]",t),!0);j.title="DeprecationWarning";var v=j,k=w;v.once=(...e)=>!w.includes(e[1]||e[0])&&j.apply(void 0,e),v._list=k;const{ALGORITHM:$}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class S{constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!$.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${$.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=b.normalizeInput(e);const t=l.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=b.normalizeInput(e);const t=l.createDecipheriv(this.algorithm,this.key,this.iv,this.options),a=t.update(e,"hex","utf8")+t.final("utf8");return b.normalizeOutput(a)}static getCiphers(){return l.getCiphers()}static getHashes(){return l.getHashes()}static md5(e){return v('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),l.createHash("md5").update(e).digest("hex")}static sha1(e){return v('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),l.createHash("sha1").update(e).digest("hex")}static hash(e,t){if(S.hasHash(t))return l.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==S.getHashes().indexOf(e)}}var C=S;const x=new C("af6f97dbaa3ed81e9fc4"),{log:O}=console;const q=require("../../package.json"),{log:P}=console,I=e=>t=>P(c`{redBright Error} in {red ${e}}\n${t}\n`),L=async(e,t,a,i)=>{const n=new C("af6f97dbaa3ed81e9fc4"),r=n.encode(i),s=n.encode(e);return await o(`${t}/${s}.js`,`module.exports="${r}";`),global.watch||P(c`encrypted {magenta ${e}} to {green ${s}}`),a.encrypt[s]=`${s}=require("./${s}")`,a},N=async(e,t)=>{await L("specs",e,t,t.specs),await L("grammar",e,t,t.bb7485c5a2338a);const{parsing:a}=(e=>{const{parsing:t,cache:a,cache:{standard:i}}=e;for(const n in a){"object"!=typeof t[n]&&(t[n]={});const{filter:o=[],object:r=[]}=a[n];e.parsing[n].objects=[...r].sort(),e.parsing[n].filters="standard"!==n?[...o,...i.filter].sort():i.filter.sort()}return e})(t),{encrypt:i}=await L("parsing",e,t,a),n=`${"const "+Object.values(i).join(",")};module.exports={${Object.keys(i).join(",")}};`;await o(e+"/index.js",n)},E=(t,a)=>async i=>{const n=i?`${t}/${i}`:t,o=e(n).replace(/\.[^/.]+$/,""),s=await r(n),c=m(s.toString()),l=JSON.parse(d(c)),{cache:p}=((e,t,a)=>{t.cache[e]={deprecated:[]};for(const[i,{type:n,deprecated:o}]of Object.entries(a))t.cache[e][n]||(t.cache[e][n]=[]),o?t.cache[e].deprecated.push(i):t.cache[e][n].push(i);return t})(o,a,l);a.specs[o]=l,a.grammar[o]=((e,t={})=>{for(const a in e)e[a].length&&(t[a]=`(${e[a].join("|")})`);return t})(p[o])},B=async(e,t,a)=>{const i=await n(e),o=E(e,a),r=I(e);for(const e of i)await o(e).catch(r);return await N(t,a).catch(r),a};const D=async e=>{const t=await r(e),a=m(t.toString()),i=JSON.parse(a);return i.$schema&&delete i.$schema,i};var H={engine:"pnpm",interface:{command:"liquify",description:"This CLI is used for developing the Liquify IDE tool and provides a command line interface to bundle, package and maintain the project.",commands:[{command:"git",description:"Common git related operations for the project"},{command:"package",description:"Common git related operations for the project"},{command:"peek",description:"Common git related operations for the project"},{command:"publish",description:"Common git related operations for the project"}],packages:[{package:"@liquify/clients",command:"client",filters:[{command:"vscode"},{command:"sublime"},{command:"atom"}],description:"Build and compile bundles"},{package:"@liquify/liquid-language-grammars",command:"grammar",filters:[{command:"create"}],description:"Packaging execution, eg: npm pack"},{package:"@liquify/schema-stores",command:"schema",description:"Common git related operations for the project"},{package:"@liquify/liquid-language-server",command:"server",description:"Publish to CDN, Netlify, Marketplace etc"},{package:"@liquify/specs",command:"specs",description:"Publish to CDN, Netlify, Marketplace etc"}],flags:[{name:"config",short:"c",description:"Use configuration file (defaults to `.liquifyrc.json`"},{name:"watch",short:"w",description:"Watch and bundle file/s"},{name:"main",short:"m",description:"Define a main (entry) configuration file"},{name:"input",short:"i",description:"Input path to directory of file/s"},{name:"output",short:"o",description:"Output path destination of bundled file/s"},{name:"prod",short:"p",description:"Production bundle build"},{name:"dev",short:"d",description:"Develop bundle build (default)"},{name:"postinstall",short:"pi",description:"Post install"},{name:"help",short:"h",description:"Shows the CLI help and commands list"}]}},R={banner:({name:t,main:a,version:i,author:n})=>`\n/**\n * @license\n *\n * THIS IS PROPRIETARY CODE\n *\n * Copyright of Vellocet, Inc - All Rights Reserved.\n * Unauthorized copying or modification of this file, via any medium is strictly prohibited.\n * Please refer to the LICENSE.txt and/or ThirdPartyNotices.txt files included in bundle.\n *\n * ${e(a)}\n *\n * Package:  ${t}\n * Version:  ${i}\n * Updated:  ${new Date(s(a).mtimeMs).toISOString().replace(/T/," ").substr(0,19)}\n * Website:  https://www.liquify.dev\n * License:  See LICENSE\n *\n * Written by ${n}\n *\n */`};const M=async r=>{const s=process.cwd(),l=(({_:[e,t=null]})=>{for(const{command:a,filters:i}of H.calls){if(console.log(a===e),a===e)return{command:a,filter:t};if(a===e&&t&&i.length>0)for(const e of i)if(e.command===t)return{command:a,filter:t}}})(r);if(console.log(r),!l)return I("Command\n")(JSON.stringify(l));const m=((e,a)=>async([i,n])=>{for(const{name:o,short:r}of H.options)o!==i&&r!==i||await Object.assign(a,{[o]:["config","main","input","output","peek"].includes(o)?t(e,n):n})})(s,l);switch(Object.entries(r).forEach(await m),l.command){case"specs":await(async(t,a={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const{input:i,output:n}=t,o=I(i);if(t.watch){P(c`{bold.cyan Liquid Specifications}\n`),await B(i,n,a).catch(o);const t=h.watch(i+"/**",{persistent:!0}),r=((t,a)=>async i=>{const n=e(i),o=I(n);P(c`{cyan changed} '{yellow ${n}}'`);const r=E(i,a);await r().catch(o),await N(t,a).catch(o)})(n,a);global.watch=!0,t.on("change",r).on("error",o)}else P(c`{bold.cyan Liquid Specifications}\n`),await B(i,n,a).catch(o)})(l);break;case"peek":await(async o=>{const{input:r}=o,s=await n(r),l=(a=>i=>"index"!==(i=e(i).replace(/\.[^/.]+$/,""))&&(c`${x.decode(i)}    {dim.magenta ${i} }`,t(a,i)))(r),p=s.map(l).filter(Boolean),{file:m}=await a.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:p}]),d=await i("pnpx",["fx",m+".js"],{stdio:"inherit"});try{await d}catch(e){O(""+e.shortMessage)}})(l);break;case"grammar":await(async(e,a={specs:{},cache:{},grammar:{},parsing:{},encrypt:{}})=>{const{output:i}=e,n=process.cwd(),r=await D(e.main),s=await D(t(n,r.input)),l=await(async e=>x.decode(p.bb7485c5a2338a))(),m=(h=i,async({input:e,output:t})=>{const a=await D(e),i=d(JSON.stringify(a)),n=f.stringify(a);await o(`${h}/${t}.json`,i),P(c`{cyan JSON Injection} {green ${t}.json}`),await o(`${h}/${t}.yaml`,n),P(c`{yellow YAML Injection} {green ${t}.yaml}`)});var h;const u=(async(e,t,a)=>a=>{if(!e[a.variant])return;const{repository:i}=t,{object:n}=e[a.variant];i.objects.patterns})(l,s);r.injections.forEach(await m),r.variations.forEach(await u)})(l);break;default:await(async(e=[{type:"list",name:"run",message:"Select operation:",choices:[c`Bundle    {gray.italic Build and compile bundles}`,c`Package   {gray.italic Packaging execution, eg: npm pack}`,c`Git       {gray.italic Common git related operations for the project}`,c`Publish   {gray.italic Publish to CDN, Netlify, Marketplace etc}`,c`Test      {gray.italic Run various tests}`,c`Config    {gray.italic Project configuration and settings}`]}])=>{y(!0),P(c`{cyan ${g.textSync("Liquify CLI",{font:"Slant",horizontalLayout:"controlled smushing"})}}`),P(u([c`{magentaBright Package}{dim :} ${q.name}                              `,c`{magentaBright Version}{dim :} ${q.version}                           `,c`{magentaBright Private}{dim :} ${q.private}`].join("\n"),{padding:0,borderColor:"gray",dimBorder:!0,borderStyle:{topLeft:" ",topRight:" ",bottomLeft:" ",bottomRight:" ",horizontal:"-",vertical:" "}}));const{run:t}=await a.prompt(e);return t.toLowerCase().substring(0,t.indexOf(" ")),await(async()=>{const{bundle:e}=await a.prompt([{type:"list",name:"bundle",message:"Select Bundle",choices:[c`Client    {gray.italic Build and compile bundles}`,c`Grammar   {gray.italic Packaging execution, eg: npm pack}`,c`Schema    {gray.italic Common git related operations for the project}`,c`Server    {gray.italic Publish to CDN, Netlify, Marketplace etc}`,c`Specs     {gray.italic Run various tests}`,c`{magenta < Go Back}`]}]),t=e.toLowerCase().substring(0,e.indexOf(" ")),n=I(t);return await i("pnpm",["run","build","--filter","./packages/specs"],{stdio:"inherit"}).catch(n)})()})()}};export{R as rollup,M as run};
