import e,{resolve as t,basename as r}from"path";import o from"chalk";import n from"crypto";import"@liquify/specs";import s from"fs";import i from"util";import"fs-extra";import"boxen";import"strip-json-comments";import"jsonminify";import"execa";import"chokidar";import"json-to-pretty-yaml";import"console";var a=class{static normalizeInput(e){if(null==e)throw new Error("required origin");return"object"==typeof e&&(e=JSON.stringify(e)),"string"!=typeof e&&(e=e.toString()),e}static normalizeOutput(e){try{return JSON.parse(e)}catch(t){return e}}};const c=[],p=(e,t)=>void 0!==e&&(t=t||e,c.includes(t)||c.push(t),console.warn("["+p.title+"]",t),!0);p.title="DeprecationWarning";var l=p,d=c;l.once=(...e)=>!c.includes(e[1]||e[0])&&p.apply(void 0,e),l._list=d;const{ALGORITHM:u}={ALGORITHM:["aes-256-cbc","aes-256-cbc-hmac-sha1","aes-256-cbc-hmac-sha256","aes-256-cfb","aes-256-cfb1","aes-256-cfb8","aes-256-ctr","aes-256-ofb","aes256","camellia-256-cbc","camellia-256-cfb","camellia-256-cfb1","camellia-256-cfb8","camellia-256-ofb","camellia256"]};class f{constructor(e,t="aes-256-ctr"){if("string"!=typeof e)throw new Error("required an string key");if(""===e)throw new Error("key cannot be empty");if(!u.includes(t))throw new Error(`algorithm ${t} not supported, use those available: ${u.join(", ")}`);e=this.constructor.hash(e,"md5"),Object.defineProperties(this,{algorithm:{value:t},key:{value:e},iv:{value:e.substr(16)},options:{value:{}}})}encode(e){e=a.normalizeInput(e);const t=n.createCipheriv(this.algorithm,this.key,this.iv,this.options);return t.update(e,"utf8","hex")+t.final("hex")}decode(e){e=a.normalizeInput(e);const t=n.createDecipheriv(this.algorithm,this.key,this.iv,this.options),r=t.update(e,"hex","utf8")+t.final("utf8");return a.normalizeOutput(r)}static getCiphers(){return n.getCiphers()}static getHashes(){return n.getHashes()}static md5(e){return l('md5 is deprecated, use hash method instead. e.g. hash("your string", "md5")'),n.createHash("md5").update(e).digest("hex")}static sha1(e){return l('sha1 is deprecated, use hash method instead. e.g. hash("your string", "sha1")'),n.createHash("sha1").update(e).digest("hex")}static hash(e,t){if(f.hasHash(t))return n.createHash(t).update(e).digest("hex");throw new Error("hash "+t+" not found in your platform")}static hasHash(e){return-1!==f.getHashes().indexOf(e)}}var m=f;const h=require("./../package.json"),y=new m("af6f97dbaa3ed81e9fc4"),{log:w}=console,g=o.redBright;var v=Object.freeze({__proto__:null,pkg:h,crypto:y,log:w,error:g}),b="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function x(e,t){return e(t={exports:{}},t.exports),t.exports}x((function(e,t){
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright Â© 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
!function(r){t?e.exports=r():"undefined"!=typeof window?window.isWindows=r():void 0!==b?b.isWindows=r():"undefined"!=typeof self?self.isWindows=r():this.isWindows=r()}((function(){return function(){return process&&("win32"===process.platform||/^(msys|cygwin)$/.test(process.env.OSTYPE))}}))}));const k=(e,...t)=>new Promise(r=>{r(e(...t))});var j=k,O=k;j.default=O;const S=e=>{if(!Number.isInteger(e)&&e!==1/0||!(e>0))return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));const t=[];let r=0;const o=()=>{r--,t.length>0&&t.shift()()},n=(e,t,...n)=>{r++;const s=j(e,...n);t(s),s.then(o,o)},s=(o,...s)=>new Promise(i=>((o,s,...i)=>{r<e?n(o,s,...i):t.push(n.bind(null,o,s,...i))})(o,i,...s));return Object.defineProperties(s,{activeCount:{get:()=>r},pendingCount:{get:()=>t.length},clearQueue:{value:()=>{t.length=0}}}),s};var P=S,C=S;P.default=C;class E extends Error{constructor(e){super(),this.value=e}}const H=async(e,t)=>t(await e),I=async e=>{const t=await Promise.all(e);if(!0===t[1])throw new E(t[0]);return!1},z=async(e,t,r)=>{r={concurrency:1/0,preserveOrder:!0,...r};const o=P(r.concurrency),n=[...e].map(e=>[e,o(H,e,t)]),s=P(r.preserveOrder?1:1/0);try{await Promise.all(n.map(e=>s(I,e)))}catch(e){if(e instanceof E)return e.value;throw e}};var D=z,T=z;D.default=T;const{promisify:W}=i,_=W(s.stat),q=W(s.lstat),L={directory:"isDirectory",file:"isFile"};function N({type:e}){if(!(e in L))throw new Error("Invalid type specified: "+e)}const $=(e,t)=>void 0===e||t[L[e]]();var A=async(t,r)=>{N(r={cwd:process.cwd(),type:"file",allowSymlinks:!0,...r});const o=r.allowSymlinks?_:q;return D(t,async t=>{try{const n=await o(e.resolve(r.cwd,t));return $(r.type,n)}catch(e){return!1}},r)};A.sync=(t,r)=>{N(r={cwd:process.cwd(),allowSymlinks:!0,type:"file",...r});const o=r.allowSymlinks?s.statSync:s.lstatSync;for(const n of t)try{const t=o(e.resolve(r.cwd,n));if($(r.type,t))return n}catch(e){}};const{promisify:B}=i,G=B(s.access);var J=async e=>{try{return await G(e),!0}catch(e){return!1}};J.sync=e=>{try{return s.accessSync(e),!0}catch(e){return!1}};var M=x((function(t){const r=Symbol("findUp.stop");t.exports=async(t,o={})=>{let n=e.resolve(o.cwd||"");const{root:s}=e.parse(n),i=[].concat(t),a=async e=>{if("function"!=typeof t)return A(i,e);const r=await t(e.cwd);return"string"==typeof r?A([r],e):r};for(;;){const t=await a({...o,cwd:n});if(t===r)return;if(t)return e.resolve(n,t);if(n===s)return;n=e.dirname(n)}},t.exports.sync=(t,o={})=>{let n=e.resolve(o.cwd||"");const{root:s}=e.parse(n),i=[].concat(t),a=e=>{if("function"!=typeof t)return A.sync(i,e);const r=t(e.cwd);return"string"==typeof r?A.sync([r],e):r};for(;;){const t=a({...o,cwd:n});if(t===r)return;if(t)return e.resolve(n,t);if(n===s)return;n=e.dirname(n)}},t.exports.exists=J,t.exports.sync.exists=J.sync,t.exports.stop=r}));M.sync,M.exists,M.stop;var R={commands:[{command:"bundle",description:"Bundler"},{command:"git",description:"Common git related operations for the project"},{command:"package",description:"Common git related operations for the project"},{command:"peek",description:"Common git related operations for the project"},{command:"publish",description:"Common git related operations for the project"}],flags:[{name:"config",short:"c",description:"Use configuration file (defaults to `.liquifyrc.json`"},{name:"watch",short:"w",description:"Watch and bundle file/s"},{name:"main",short:"m",description:"Define a main (entry) configuration file"},{name:"input",short:"i",description:"Input path to directory of file/s"},{name:"output",short:"o",description:"Output path destination of bundled file/s"},{name:"prod",short:"p",description:"Production bundle build"},{name:"dev",short:"d",description:"Develop bundle build (default)"},{name:"help",short:"h",description:"Shows the CLI help and commands list"},{name:"version",short:"-v",description:"Shows the CLI help and commands list"},{name:"postinstall",description:"Post install"},{name:"preinstall",description:"Pre install"},{name:"dry-run",description:"Dry runner"}]};export default async e=>{const o=Object.create(null),n=await(async(e,{packages:o})=>{e.packages=o;const n=[],s=process.cwd(),i=r(t(s,"root")),a=r(s);e.root=await M("project",{type:"directory"});for(const t in o){const[r]=Object.keys(o[t]);n.push({command:t,description:r}),a!==t&&i!==t||(e.active=t)}return n})(o,(await Promise.resolve().then((function(){return v}))).pkg);return o.cwd=process.cwd(),R.commands=[...R.commands,...n],await(async(e,r,{_:[o,n=null]})=>{const{commands:s}=r,{packages:i}=e;for(const{command:t,short:r}of s){const s=t===o||r===o;if(s&&!n){e.command=t;break}if(s&&n&&n.length>0){for(const r in i)r===n&&(e.command=t);break}}for(const r in i)if(r===e.command){const[o]=Object.values(i[r]);e.path=t(e.cwd,o)}return e.command})(o,R,e),console.log(o)};
